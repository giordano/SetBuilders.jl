var documenterSearchIndex = {"docs":
[{"location":"description/#Set-Description","page":"Set Description","title":"Set Description","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"This section introduces on generating detailed set descriptions. ","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The format of set description is drawn from the set-builder notation in mathematics, like '{ x ∈ R | 0 < x < 4 }'.","category":"page"},{"location":"description/#Sets-from-Julia-types","page":"Set Description","title":"Sets from Julia types","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"I = @setbuild(Integer)\n\nprintln(describe(I))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Overall, the description is similar to the set-builder notation. The double colon indicates of Julia type.","category":"page"},{"location":"description/#Enumerable-Set","page":"Set Description","title":"Enumerable Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"E1 = @setbuild([1, 2, 3])\n\nprintln(describe(E1))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ ::Int64*3 }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"In addition to the output seen with a set with Julia type, the *3 indicates that the set is EnumerableSet and the number of elements in the set is 3.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"E2 = @setbuild(Union{Int64, Float64}[1, 2, 3.0])\n\nprintln(describe(E2))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ (::Float64*1, ::Int64*2) }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The tuple indicates that the set E2 can have members of the Float64 or Int64 types, and the number of elements is 1 and 2, respectively.","category":"page"},{"location":"description/#Cartesian-Set","page":"Set Description","title":"Cartesian Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"C = @setbuild((I, I))\n\nprintln(describe(C))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ c1 ∈ A, c2 ∈ B }, where\n    A = { x ∈ ::Integer }\n    B = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The members of the cartesian set C are pairs of two elements from set I. The c1 and c2 set variables and set names of A and B are automatically created by SetBuilders. The set A is the first set and B is the second set in the original cartesian set definition.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Each set A and set B are futher described with indentation.","category":"page"},{"location":"description/#Predicate-Set","page":"Set Description","title":"Predicate Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"P1 = @setbuild(x in I, 0 <= x < 10)\n\nprintln(describe(P1))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ A | 0 <= x < 10 }, where\n    A = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The left side of the vertical bar represents the set variable part, and the right side represents the predicate part.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"P2 = @setbuild(x in I, 5 <= x < 15)\nP3 = @setbuild((x in P1, y in P2), x < 5 && y > 10)\n\nprintln(describe(P3))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ A, y ∈ B | x < 5 && y > 10 }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n        A.A = { x ∈ ::Integer }\n    B = { x ∈ B.A | 5 <= x < 15 }, where\n        B.A = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The output indicates that the members of set P3 are pairs of elements, each from sets A and B, with the predicates 'x < 5 && y > 10'. The members of sets A and B are Julia Integer values, each with the predicates '0 <= x < 10' and '5 <= x < 15', respectively. To indicate the hierarchy of sets, a dot ('.') is inserted between the capital letters, such as 'A.A'. The capital letter progresses from A to Z and starts again from A if the number of sets exceeds the number of alphabets such as \"AA.A\".","category":"page"},{"location":"description/#Mapped-Set","page":"Set Description","title":"Mapped Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"M1 = @setbuild(x in P1, z in I, z = x + 5, x = z - 5)\n\nprintln(describe(M1))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n        A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n    B = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The first set description at the top of the output is the source set of the 'forward mapping', denoted as 'F-MAP'. Right below the forward mapping arrow is the destination set. 'B-MAP' indicates 'backward mapping' from the destination set to the source set.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"With indentation, the sets and mappings used in the construction of MappedSet are further described.","category":"page"},{"location":"description/#Marking-a-set-in-description","page":"Set Description","title":"Marking a set in description","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Set operations and mappings make it easy to build a new set from multiple sets. Therefore, we can conveniently and systematically describe a complex condition using a set or a composite of sets generated from set operations and mappings.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"However, as the number of sets involved in describing a condition increases, analyzing the structure and relationships between the sets becomes more challenging.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The describe function features a way to mark a specific set that is part of a larger set, enabling users to easily pinpoint a specific set for a certain purpose.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"In previous examples, set M1 uses sets P1 and I, and set P1 uses set I. Assuming we want to know all the cases in which set I is used in set M1, we can use the describe function as follows:","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"println(describe(M1, mark=I))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"produces","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n     => A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n => B = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Note that there are two positions where set I is being used pointed by \"=>\" mark.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"In case that a different mark is preferred, we can use a tuple with a new mark as following:","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"println(describe(M1, mark=(I, \"## \")))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"produces","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n     ## A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n ## B = { x ∈ ::Integer }","category":"page"},{"location":"creation/#Set-Creation","page":"Set Creation","title":"Set Creation","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The @setbuild macro in SetBuilders is the primary interface for creating sets.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With this macro, users can create sets from Julia types, predicates, mappings, and lists of elements.","category":"page"},{"location":"creation/#Empty-Set-and-Universal-Set","page":"Set Creation","title":"Empty Set and Universal Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Let's start with the simplest ones: the empty set and the universal set.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"E = @setbuild()     # Empty set\nU = @setbuild(Any)  # Universal set\n\n@assert !(1 in E)   # No elements in EmptySet\n@assert 1 in U      # Any element is a member of UniversalSet","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With no argument, @setbuild creates an empty set, which does not contain any elements. All membership tests with EmptySet returns Boolean false.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"note: Note\nAll @assert tests in the examples of this page should pass.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"In Julia, the Any type is a special type that sits at the top of the type hierarchy. With the Any type, @setbuild creates the universal set, which includes all objects in Julia. All membership tests with UniversalSet returns Boolean true.","category":"page"},{"location":"creation/#Set-from-Julia-Types","page":"Set Creation","title":"Set from Julia Types","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With Jula type, @setbuild creates a set that includes all instances of that type.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"I = @setbuild(Integer)\n\n@assert 1 in I              # 1 is one instance of an Integer subtype\n@assert !(1.0 in I)         # 1.0 is one instance of a Real subtype, not an Integer subtype","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set I includes instances of all subtypes of Integer (BigInt, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8, and Bool).","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Please note that the set I \"conceptually includes\" such elements, but does not actually \"contain\" them. The membership evaluation is performed \"lazily\" at the time of checking.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"R = @setbuild(Real)\n\n@assert 1.0 in R            # 1 is one instance of a Real subtype\n@assert !(1.0im in R)       # 1.0im is one instance of a Complex type, not a Real subtype","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Similarly, the set R includes all instances of all subtypes of the Real type, encompassing all subtypes of Integer, AbstractFloat, AbstractIrrational, and Rational types.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"struct MyStruct\n    a\n    b\nend\n\nS = @setbuild(MyStruct)\n\n@assert MyStruct(1,2) in S  # MyStruct(1,2) is one instance of a MyStruct type\n@assert !(1 in S)           # 1 is not an instance of MyStruct type","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Note also that @setbuild can create sets from user-defined types. The set S includes all instances of the MyStruct type.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The following diagram depicts the three sets in the above example.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"(Image: Sets from Julia types)","category":"page"},{"location":"creation/#Enumerable-Set","page":"Set Creation","title":"Enumerable Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Similar to Julia's Set data structure, @setbuild can create a set from a list of elements.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The brackets([ and ] in the first @setbuild argument directs to build an enumerable set.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"A = @setbuild([1, 2, 3])\n\n@assert 1 in A      # 1 is one of the elements of set A\n@assert !(4 in A)   # 4 is not an element of set A","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set A in the above example is created with three elements.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Note that the Setbuilders Enumerable Set actually 'contains' the elements in the same way as the Set data structure in Julia.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"value = 10\n\nB = @setbuild(Int64[value, 2])\n\n@assert value in B              # `value` defined outside of `@setbuild` is used\n@assert !(Int32(value) in B)    # Set B can contain `Int64` type, not `Int32`\n@assert !(3 in B)               # 3 is not an element of set B\npush!(B, 3)                     # 3 is added into set B\n@assert 3 in B                  # Now, 3 is a member of set B\npop!(B, 3)                      # 3 is removed from set B\n@assert !(3 in B)               # 3 is not a member of set B","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Users can specify the type of elements, as shown in the set B. There is one difference in handling the type of elements compared to Julia's Set. When an element is \"pushed\" into the set, SetBuilder enumerable sets do not promote the element's type, whereas Julia Set does.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The above example demonstrates how to add and remove an element to/from an EnumerableSet using the push! and pop! functions, similar to the Set in Julia.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"C = @setbuild(Dict{String, String}[])\n\nd1 = Dict{String, String}(\"a\" => \"x\")\nd2 = Dict{String, Integer}(\"a\" => 1)\n@assert !(d1 in C)                  # d1 is not a member of set C\npush!(C, d1)                        # d1 is added to set C\n@assert d1 in C                     # d1 is a member of set C\npush!(C, d2)                        # d2 can not be \"pushed\" to set C, due to type-mismatch\nERROR: push! failed due to element type mismatch: Dict{String, Integer} not in \nataType[Dict{String, String}].\n@assert !(d2 in C)                  # d2 is not a member of set C","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"EnumerableSet can accept instances of all Julia types as a member. Set C in the above example accepts a dictionary data structure with String key and String value. Note that the square brackets in the @setbuild arguement indicates for creation of an EnumerableSet.","category":"page"},{"location":"creation/#Cartesian-Product-Set","page":"Set Creation","title":"Cartesian Product Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"In some cases, we may want to create a set by selecting elements from each set and arranging the chosen elements in order, known as the Cartesian product.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"D = @setbuild((I, I))","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set D includes all pairs of elements from the set I, previously defined in the example above as a set of Julia Integer type.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"F = @setbuild((x, y) in I)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set F offers another syntax for creating a set of Integer pairs, similar to the set D.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"G = @setbuild((I^3, z in I))","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set G demonstrates another syntax for creating a Cartesian product set with the 4-ary Cartesian product set.","category":"page"},{"location":"creation/#Predicate-Set","page":"Set Creation","title":"Predicate Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Predicates are logical formulas that yield true for set members. In SetBuilders, predicates can be any expressions yielding a Boolean result, including functions.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"H = @setbuild(x in I, 0 <= x < 10)\n\n@assert 0 in H\n@assert !(10 in H)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set H in the above example has two arguments. The first argument defines the domain of the sets. In other words, all members of the set H should also be members of the set I, defined as an Integer set. Additionally, all members of these sets should satisfy the Boolean expression of the second argument.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The following diagram depicts the relation between the domain set I and the predicate set H.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"(Image: Predicate set)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"K = @setbuild((x in H, y in J), x < 5 && y > 10)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set K demonstrates how to define the domain of a set using multiple sets.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"L = @setbuild((x in H, y in J), c1*x + c2*y > 0, c1=-1, c2=1)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set L shows how to use values defined outside of the @setbuild macro.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"N = @setbuild(x in @setbuild(Real), x > 0)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set N illustrates that the @setbuild macro can be nested within another @setbuild macro.","category":"page"},{"location":"creation/#Mapped-Set","page":"Set Creation","title":"Mapped Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With a Mapped Set, users can create a set using mappings from one set to another.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"O = @setbuild(x in H, z in I, z = x + 5, x = z - 5)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"A \"Mapped Set\" should have at least four arguments.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The first argument defines the source set, or domain in mathematical term, of a mapping. The mapping starts from the elements of the set H.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The second argument defines the destination set , or codomain, of a mapping. The mapping arrives at the elements of the set I.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The third argument defines a \"forward\" mapping from the source set (H, domain) to the destination set (I, codomain). The mapping at the third argument defines the way how to generated an element(or elements) in the codomain.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The fourth argument defines a \"backward\" mapping from the destination set (I, codomain) to the source set (H, domain). The mapping at the fourth argument defines the way how to generated an element(or elements) in the domain.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"(Image: Mapping in the set O)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"function myfunc(x)\n    x - 5\nend\n\nP = @setbuild(x in J, z in I, z = x + 5, x = func(z), func=myfunc)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set P demonstrates how to use a function defined outside of @setbuild to create a mapping.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Q = @setbuild((x in H, y in J), z in S, z = mystruct(x, y),\n                (x, y) = (z.a, z.b), mystruct=MyStruct)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set Q shows that a mapped set can map to a user-defined type.","category":"page"},{"location":"event/#Set-Event","page":"Set Event","title":"Set Event","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"SetBuilders provides users with the capability to register callback functions, so they can be called when an event occurs during operation.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The situations in which an event occurs can vary. As of this writing, membership events and mapping events are supported.","category":"page"},{"location":"event/#Membership-events","page":"Set Event","title":"Membership events","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Membership events occur during membership check using ismember function.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Note that membership check operators of in or ∈ can not be used for event handling.","category":"page"},{"location":"event/#Creating-a-callback-function","page":"Set Event","title":"Creating a callback function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"When an event occurs, SetBuilders makes a call to the registered callback function with one argument that is a vector of named tuple(:set and :elem).","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Let's start by creating a callback function.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"function F1(history)\n    desc = describe(history[1].set, mark=history[end].set)\n    println(\"#############\")\n    println(\"Not a Member\")\n    println(\"-------------\")\n    println(desc)\n    println(\"-------------\")\n    println(\", because '$(history[end].elem)' is not a member of the set pointed by '=>'\")\n    println(\"#############\")\nend","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The function F1 takes one argument, history, which contains all the sets visited during the membership check and the elements used in these sets.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The first item in the vector is the tuple of the set specified as the first argument and the value as the second argument of the ismember function.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The last item in the vector is the tuple of the set and the element at the time the event occurred.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"To illustrate, we used the describe function with the mark keyword argument to mark the last visited set where the event occurred. See Marking a set in description for an explanation of how to use the mark keyword argument in the describe function.","category":"page"},{"location":"event/#Registering-a-callback-function","page":"Set Event","title":"Registering a callback function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Once a callback function is created, registering it to the ismember function is straightforward.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"I = @setbuild(Integer)\nP1 = @setbuild(x in I, 0 <= x < 10)\nM1 = @setbuild(x in P1, z in I, z = x + 5, x = z - 5)\n\nismember(0, M1, on_nomember=F1)","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"To register a callback function when a membership failure event occurs, we used the on_nomember keyword argument. In the case of a membership success event, on_member is used.","category":"page"},{"location":"event/#Reading-output-from-the-callback-function","page":"Set Event","title":"Reading output from the callback function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The previous example produces:","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"#############\nNot a Member\n-------------\n\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n => A = { x ∈ A.A | 0 <= x < 10 }, where\n        A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n    B = { x ∈ ::Integer }\n-------------\n, because '-5' is not a member of the set pointed by '=>'\n#############\nfalse","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The output shows that the membership test failed at set A, originally named P1, because the value -5 is not a member of set P1.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The value -5 was calculated using B-MAP from the original argument value of 0 to -5, using the formula x = z - 5.","category":"page"},{"location":"event/#Mapping-Events","page":"Set Event","title":"Mapping Events","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Mapping events occur during the generation of elements using the fmap and bmap functions.","category":"page"},{"location":"event/#Creating-a-Callback-Function","page":"Set Event","title":"Creating a Callback Function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"When an event occurs, SetBuilders calls the registered callback function with a single argument: a vector of named tuples. The contents of these named tuples vary depending on the type of event.","category":"page"},{"location":"event/#Types-of-Mapping-Events","page":"Set Event","title":"Types of Mapping Events","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Source Domain Failure: Occurs when the source membership check fails.\nevent: :source_membership_fail\nelement: The source element used for the failed membership check\nsettuple: A tuple consisting of the set variable name and the set\nSource Predicate Failure: Occurs when the source predicate check fails.\nevent: :source_predicate_fail\nelement: The source element used for the failed predicate check\npredicate: The source predicate used\nTarget Membership Failure: Occurs when the target membership check fails.\nevent: :target_membership_fail\nelement: The target element used for the failed membership check\nsettuple: A tuple consisting of the set variable name and the set\nTarget Predicate Failure: Occurs when the target predicate check fails.\nevent: :target_predicate_fail\nelement: The source element used for the failed predicate check\npredicate: The target predicate used","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Let's begin by creating a callback function.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"F1 = events -> println(\"$(events[end].event) has occured.\")","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The function F1 takes one argument, events, which contains all the events that occurred during the mapping.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The first item in the vector is the tuple of named sets, as explained in Types of Mapping Events.","category":"page"},{"location":"event/#Registering-a-Callback-Function","page":"Set Event","title":"Registering a Callback Function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Once a callback function is created, registering it with the fmap or bmap functions is straightforward.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"fmap(M1, -1, on_nomapping=F1)","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"To register a callback function for when a mapping failure event occurs, we use the on_nomapping keyword argument. For a mapping success event, on_mapping is used.","category":"page"},{"location":"event/#Reading-Output-from-the-Callback-Function","page":"Set Event","title":"Reading Output from the Callback Function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The previous example produces:","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"source_membership_fail has occurred.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The output indicates that the mapping failed because the input -1 is not a member of the domain set of M1, which is P1 in this example.","category":"page"},{"location":"sharing/#Set-Sharing","page":"Set Sharing","title":"Set Sharing","text":"","category":"section"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"As we describe more complex situations by combining various sets, we may find ourselves creating numerous sets together. Alternatively, we might need to use a set that was developed by another programmer. To facilitate these scenarios, SetBuilders enables the definition of sets outside the current execution environment, such as from an external file.","category":"page"},{"location":"sharing/#Loading-Set-Module","page":"Set Sharing","title":"Loading Set Module","text":"","category":"section"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"At the time of this writing, SetBuilders offers functionality to load sets from a Julia module, which could be housed in a file.","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"path = \"path/to/set/module\"\n@setpkg load path","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"The @setpkg macro, when used with the \"load\" sub-command, loads a Julia module from the specified file. This file should be a regular Julia module that exports sets.","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"module MySetModule\nexport MySet\n\nMySet = @setbuild(Integer)\nend","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"To use the exported set, you can use @setpkg load command as shown below:","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"@setpkg load \"path/to/set/module\"\nusing SetBuilders.MySetModule\n\n@assert 1 in MySet","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"To reduce the chance of naming pollution, the set module is imported beneath the SetBuilders module. Apart from this, it can be treated as a regular Julia module.","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"The SetBuilders set module is an extension of the Julia module. The @expect macro requires users of the set module to provide \"expected\" values, while the @option macro defines optional information. These extensions assist the set developer in creating sets independently from the set users.","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"module MySetModule\n\nexport MySet\n\n@expect(x::Integer)\n@option(y::Integer)\n\nI       = @setbuild(Integer)\nMySet   = @setbuild(z in I, z + x > 0, x=x)\n\nend","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"The expected value x can be provided as demonstrated below.","category":"page"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"\n@setpkg load \"path/to/set/module\" x=1","category":"page"},{"location":"mapping/#Set-Element-Generation","page":"Set Element Generation","title":"Set Element Generation","text":"","category":"section"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"MappedSet contains mappings that associate each elements in the domain and the codomain. This page explains how to use the mappings to generate elements from one set to another.","category":"page"},{"location":"mapping/#Element-Generation-Overview","page":"Set Element Generation","title":"Element Generation Overview","text":"","category":"section"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Set element generation works only with MappedSet among other set types in SetBuilders. MappedSet is a set created with four elements: domain, codomain, forward-map, and backward-map.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"To demonstrate the element generations using forward mapping, as well as backward mapping, the following sets are prepared.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"struct MyStruct\n    a\n    b\nend\n\nI  = @setbuild(Integer)\nS  = @setbuild(MyStruct)\nM1 = @setbuild(\n        (x, y) in I,        # domain: a pair of integer values\n        z in S,             # codomain: an instance of a MyStruct type\n        z = mystruct(x, y), # forward mapping: MyStruct z from the pair in the domain\n        (x, y) = (z.a, z.b),# backward mapping: The domain is recovered from MyStruct fields\n        mystruct=MyStruct   # Let SetBuilders know the name of mystruct\n    )","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"The following diagram depicts the mappings between the domain and the codomain of set M1.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"(Image: Mapping in the set M1)","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Set I is a set of Julia Integer type. Set S is a set of MyStruct user-defined type. Set M1 is a MappedSet from a pair of I (domain) to S (codomain).","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"The third argument \"z = mystruct(x, y)\" defines \"forward mapping\" from the domain to the codomain. The fourth arguemnt \"(x, y) = (z.a, z.b)\" defines \"backward mapping\" from the codomain to the domain. Finally, the last argument \"mystruct=MyStruct\" let SetBuilders know what \"mystruct\" is.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Function fmap generates set elements in codomain using the \"forward mapping\" at the third argument, and bmap generates set elements in domain using the \"backward mapping\" at the fourth element.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"The function signature of the two mapping functions is:","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"fmap(<set>, <element(s)>) # generates element(s) in codomain\nbmap(<set>, <element(s)>) # generates element(s) in codomain","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"The element(s) at the second argument should be a member of the set at the first argument. Otherwise, the mapping will fail.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Multiple elements can be specified at the second argument by using Julia Vector type, or [] operator. If a Vector is used, it will be interpresed as multiple elements. If an element is a type of Vector, then, it should be wrapped in a Vector like, [[elems...]].","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"When a single element is specifed at the second argument and the number of output elements is also a single element, the output of the mapping function will be the single element. If there are more than one elements output, then the elements will be wrapped in a Vector.","category":"page"},{"location":"mapping/#Forward-mapping-(fmap)","page":"Set Element Generation","title":"Forward mapping (fmap)","text":"","category":"section"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Forward mapping maps from the elements in the domain to the ones in codomain.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"julia> elem1 = fmap(M1, (1, 1))         # A domain element (1, 1) is mapped to MyStruct(1, 1)\nMyStruct(1, 1)\n\njulia> elem1 == MyStruct(1, 1)\ntrue\n\njulia> elem2 = fmap(M1, [(1,1), (2,2)]) # Two domain elements are mapped to two codomain elements\n2-element Vector{Any}:\n MyStruct(1, 1)\n MyStruct(2, 2)\n\njulia> elem3 = fmap(M1, (0.1, 0.1))     # No element is generated because 0.1 is not Integer type\n\njulia> elem3 isa Nothing\ntrue","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"elem1 is generated from (1, 1) domain element by appling the forward mapping \"mystruct(x, y)\".","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"A vector of a two pairs generated in elem2 by specifying a vector at the second argument of fmap.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"elem3 is nothing indicating that no element is generated because 0.1 is not a member of set I.","category":"page"},{"location":"mapping/#Backward-mapping-(bmap)","page":"Set Element Generation","title":"Backward mapping (bmap)","text":"","category":"section"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Backward mapping maps from the elements in the codomain to the ones in domain.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"The usage of bmap is exactly the same to fmap except the direction of generation.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"julia> elem4 = bmap(M1, MyStruct(1, 1))\n(1, 1)\n\njulia> elem4 == (1, 1)\ntrue\n\njulia> elem5 = bmap(M1, MyStruct(0,1, 0.1))\n2-element Vector{Any}:\n MyStruct(1, 1)\n MyStruct(2, 2)\n\njulia> elem3 = fmap(M1, (0.1, 0.1))     # No element is generated because 0.1 is not Integer type\n\njulia> elem3 isa Nothing\ntrue","category":"page"},{"location":"developer/#Developer-Documentaion","page":"Developer Documentaion","title":"Developer Documentaion","text":"","category":"section"},{"location":"developer/#Extending-SetBuilders","page":"Developer Documentaion","title":"Extending SetBuilders","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SetBuilders]\nPrivate = false","category":"page"},{"location":"reference/#SetBuilders.SetBuilders","page":"Reference","title":"SetBuilders.SetBuilders","text":"Main module for SetBuilders – Julia Package for Predicate and Enumerable Sets\n\nExports\n\n@setbuild: Builds a SetBuilders set.\n@setpkg: Loads a set from a Julia module.\nismember/in/∈: Checks if an object is a member of a set.\ndescribe: Generates a set description string.\nfmap: Converts an element in the domain to element(s) in the codomain.\nbmap: Converts an element in the codomain to element(s) in the domain.\ncomplement/~: Performs the set complement operation.\nSBSet: Represents the top-level type of all SetBuilders sets.\n\nExports through the Base Module\n\nunion/∪: Performs the set union operation.\nintersection/∩: Performs the set intersection operation.\nsetdiff/-: Performs the set difference operation.\nsymdiff: Performs the set symmetric difference operation.\npush!: Adds an element to an EnumerableSet.\npop!: Removes an element from an EnumerableSet.\n\n\n\n\n\n","category":"module"},{"location":"reference/#SetBuilders.SBSet","page":"Reference","title":"SetBuilders.SBSet","text":"SBSet - Type\n\nThe SBSet type is the supertype of all SetBuilders set types.\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> I isa SBSet\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#SetBuilders.bmap","page":"Reference","title":"SetBuilders.bmap","text":"bmap(set::MappedSet, elems; on_mapping::Function, on_nomapping::Function,\n        on_member::Function, on_nomember::Function)\n\nconvert elems in the argument to element(s) in domain of a MappedSet.\n\nKeywords\n\non_mapping: A callback function that will be called when a mapping is successful.\non_nomapping: A callback function that will be called when a mapping is not successful.\non_member: A callback function that will be called when a membership check is successful.\non_nomember: A callback function that will be called when a membership check is not successful.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SetBuilders.complement-Tuple{SBSet}","page":"Reference","title":"SetBuilders.complement","text":"complement(set <: SBSet)\n\ngenerates a complement set\n\njulia> complement(@setbuild()) == @setbuild(Any)\ntrue\n\njulia> ~@setbuild() == @setbuild(Any)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.describe-Tuple{SBSet}","page":"Reference","title":"SetBuilders.describe","text":"describe(set <: SBSet; mark=nothing, collect=nothing) :: String\n\nreturns a string describing a set\n\nExample\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> P = @setbuild(x in I, 0 <= x < 10)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> println(describe(P))\n{ x ∈ A | 0 <= x < 10 }, where\n    A = { x ∈ ::Integer }\n\nKeywords\n\nmark specifies a set to apply markings to. User also can change the marking letters by assigining a tuple of a set and a mark string.\n\njulia> println(describe(P, mark=(I, \"## \")))\n{ x ∈ A | 0 <= x < 10 }, where\n ## A = { x ∈ ::Integer }\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.fmap","page":"Reference","title":"SetBuilders.fmap","text":"fmap(set::MappedSet, elems; on_mapping::Function, on_nomapping::Function,\n        on_member::Function, on_nomember::Function)\n\nconvert elems in the argument to element(s) in codomain of a MappedSet.\n\nKeywords\n\non_mapping: A callback function that will be called when a mapping is successful.\non_nomapping: A callback function that will be called when a mapping is not successful.\non_member: A callback function that will be called when a membership check is successful.\non_nomember: A callback function that will be called when a membership check is not successful.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SBSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set <: SBSet; on_member::Function, on_nomember::Function)\n\nreturns true if elem is a member of set. Otherwise returns false.\n\nKeywords\n\non_member\n\nA callback function registered with on_member  will be called when elem is known to be a member of set.\n\non_nomember\n\nA callback function registered with on_nomember  will be called when elem is known not to be a member of set.\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> P = @setbuild(x in I, 0 <= x < 10)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> F = h -> println(describe(h[1].set, mark=h[end].set))\n#7 (generic function with 1 method)\n\njulia> ismember(-1, P, on_nomember=F)\n=> { x ∈ A | 0 <= x < 10 }, where\n    A = { x ∈ ::Integer }\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.@setbuild-Tuple","page":"Reference","title":"SetBuilders.@setbuild","text":"@setbuild([args...[; kwargs...]])\n\nThe @setbuild macro creates various SetBuilders sets.\n\nThe number of arguments varies depending on the type of set to create.\n\nNo argument\n\nEmptySet\n\njulia> @setbuild()\nEmptySet()\n\nOne argument\n\nTypeSet\n\nThe first argument is any Julia type.\n\njulia> @setbuild(Integer)\nTypeSet(Integer)\n\nEnumerableSet\n\nThe first argument is a Vector with optionally Julia type\n\njulia> @setbuild([1, 2, 3])\nEnumerableSet([{Int64}*3])\n\njulia> @setbuild(Int32[])\nEnumerableSet([{Int32}*0])\n\nUniversalSet\n\nThe first argument is Any type\n\njulia> @setbuild(Any)\nUniversalSet()\n\nTwo arguments\n\nPredicateSet\n\nThe first argument is the domain of the set. The second argument is the predicate of the set.\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> @setbuild(x in I, 0 <= x < 5)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 5)\n\nFour arguments\n\nMappedSet\n\nThe first argument is the domain of the set. The second argument is the codomain of the set. The third argument is the forward mapping of the set. The fourth argument is the backward mapping of the set.\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> @setbuild(x in I, y in I, y = x + 1, x = y - 1)\nMappedSet((x ∈ TypeSet(Integer)) -> (y ∈ TypeSet(Integer)))\n\nKeyword arguments\n\nThe main usage of keyword arguments is to provide expressions inside of @setbuild with the references defined outside of @setbuild.\n\nFor example, in the following code example, c=k keyword argument provides @setbuild macro with the value of k so that y = x + c or x = y - c can be correctly evaluated.\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> k = 1\n1\n\njulia> @setbuild(x in I, y in I, y = x + c, x = y - c, c=k)\nMappedSet((x ∈ TypeSet(Integer)) -> (y ∈ TypeSet(Integer)))\n\nnote: Note\nKeyword names starting with sb_ are reserved for internal uses by SetBuilders. The keyword arguments sbonmember and sbonnomember are equivalent to the onmember and onnomember keyword arguments for the ismember function. One difference with the sbon* keywords is that their effects apply to every membership check after the set's creation.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SetBuilders.@setpkg-Tuple","page":"Reference","title":"SetBuilders.@setpkg","text":"@setpkg command[ command-arguments... ]\n\nThe @setpkg macro enables sharing sets among developers and users.\n\ncommands\n\nload: loads sets from a local file, also known as a setfile\n\n@setpkg load <path/to/file>\n\nThe setfile is a regular Julia module customized for SetBuilders.\n\nExamples\n\nAssuming that the file myset.sjl contains the following Julia code:\n\nmodule MySetModule\n\nexport MYSET\n\nI = @setbuild(Integer)\nMYSET = @setbuild(x in I, x > 0)\n\nend\n\nMYSET can be used as shown in the example below:\n\njulia> @setpkg load \"myset.sjl\"\n\njulia> using SetBuilders.MySetModule\n\njulia> 1 in MYSET\ntrue\n\njulia> 0 in MYSET\nfalse\n\nnote: Note\nkeyword names starting with \"sb_\" are reserved for SetBuilders internal uses.\n\n\n\n\n\n","category":"macro"},{"location":"membership/#Set-Membership","page":"Set Membership","title":"Set Membership","text":"","category":"section"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"This section explains set membership checks using \"in\" or \"∈\" operators by showing various examples.","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"All of the following @assert checks should pass.","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"# test fixtures\nvalue = 10\n\nstruct MyStruct\n    a\n    b\nend\n\nfunction myfunc(x)\n    x - 5\nend\n\n# Empty set\nE = @setbuild()\n@assert !(1 in E)\n\n# Universal set\nU = @setbuild(Any)\n@assert 1 in U\n\n# sets from Julia types\nI = @setbuild(Integer)\n@assert 1 in I\n@assert !(1.0 in I)\n\nR = @setbuild(Real)\n@assert 1.0 in R\n@assert !(1.0im in R)\n\nS = @setbuild(MyStruct)\n@assert MyStruct(1,2) in S\n@assert !(1 in S)\n\n# Enumerable sets\nA = @setbuild([1, 2, 3])\n@assert 1 in A\n@assert !(4 in A)\n\nB = @setbuild(Int64[value, 2])\n@assert value in B\n@assert !(Int32(value) in B)\n@assert !(3 in B)\npush!(B, 3)\n@assert 3 in B\npop!(B, 3)\n@assert !(3 in B)\n\nC = @setbuild(Dict{String, String}[])\nd1 = Dict{String, String}(\"a\" => \"x\")\nd2 = Dict{String, Integer}(\"a\" => 1)\n@assert !(d1 in C)\npush!(C, d1)\n@assert d1 in C\n@assert !(d2 in C)\n\n# Cartesian sets\nD = @setbuild((I, I))\n@assert (1, 1) in D\n@assert !(1 in D)\n@assert !((1.0, 1.0) in D)\n\nF = @setbuild((x, y) in I)\n@assert (1, 1) in F\n@assert !(1 in F)\n@assert !((1.0, 1.0) in F)\n\nG = @setbuild((I^3, z in I))\n@assert (1, 1, 1, 1) in G\n@assert !(1 in G)\n@assert !((1.0, 1.0, 1.0, 1.0) in G)\n\n# Predicate sets\nH = @setbuild(x in I, 0 <= x < 10)\n@assert 0 in H\n@assert !(10 in H)\n\nJ = @setbuild(x in I, 5 <= x < 15)\n@assert 5 in J\n@assert !(15 in J)\n\nK = @setbuild((x in H, y in J), x < 5 && y > 10)\n@assert (4, 11) in K\n@assert !((9, 10) in K)\n\nL = @setbuild((x in H, y in J), c1*x + c2*y > 0, c1=-1, c2=1)\n@assert (5, 10) in L\n@assert !((9, 5) in L)\n\nM = @setbuild(x in I, x + y > 0, y=value)\n@assert -9 in M\n@assert !(-10 in M)\n\nN = @setbuild(x in @setbuild(Real), x > 0)\n@assert 1 in N\n@assert 1.0 in N\n@assert !(1im in N)\n\n# Mapped sets\nO = @setbuild(z in I, (x in H) -> x + 5, z -> z - 5)\n@assert 5 in O\n@assert !(0 in O)\n\nP = @setbuild(z in I, (x in J) -> x + 5, z -> func(z), func=myfunc)\n@assert 10 in P\n@assert !(5 in P)\n\nQ = @setbuild(z in S, (x in H, y in J) -> mystruct(x, y),\n                z -> (z.a, z.b), mystruct=MyStruct)\n@assert MyStruct(5, 5) in Q\n@assert !(MyStruct(10, 10) in Q)\n","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"CurrentModule = SetBuilders","category":"page"},{"location":"#SetBuilders","page":"SetBuilders Documentation","title":"SetBuilders","text":"","category":"section"},{"location":"#In-a-nutshell...","page":"SetBuilders Documentation","title":"In a nutshell...","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"SetBuilders provides Julia users with the power of predicate-based sets.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Many programming languages, including Julia, support a type of enumerable sets but not predicate sets in the mathematical sense. For instance, in Julia, it's possible to create a set containing integer values, such as","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set([1,2,3])","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, creating the following is not possible:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set(x ∈ Integer | 0 < x < 4)","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"With the SetBuilders package, Julia users can create predicate sets, compose them using set operations such as unions and intersections, and check if an object is a member of the set.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"using SetBuilders\n\nI = @setbuild(Integer)           # creates a set from Julia Integer type\nA = @setbuild(x ∈  I, 0 < x < 4) # creates a set with the predicate of \"0 < x < 4\"\nB = @setbuild(x in I, 2 < x < 6) # creates a set with the predicate of \"2 < x < 6\"\nC = A ∩ B                        # creates an intersection with the two sets\n                                 # As an alternative, \"intersect(A, B)\" can be used\n@assert 3 ∈ C                    # => true, 3 is a member of the set C\n                                 # As an alternative, \"3 in C\" can be used\n@assert !(4 in C)                # => true, 4 is not a member of the set C","category":"page"},{"location":"#Installation","page":"SetBuilders Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The package can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"pkg> add SetBuilders","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Alternatively, it can be installed via the Pkg API:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"julia> import Pkg; Pkg.add(\"SetBuilders\")","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Once installed, the SetBuilders package can be loaded with using SetBuilders.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"using SetBuilders","category":"page"},{"location":"#Sets-in-Mathematics","page":"SetBuilders Documentation","title":"Sets in Mathematics","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set theory, established by Georg Cantor in the late 19th century, is often regarded as the language of mathematics. It introduces the concept of a set as a collection of distinct objects and provides basic operations such as union, intersection, and difference. The evolution of set theory, marked by milestones like Cantor's work, Russell's Paradox, and the development of the Zermelo-Fraenkel Set Theory (ZF), has shaped it into a robust, axiomatic framework. This transformation solidified set theory's role as the universal language for expressing and structuring mathematical ideas, making it fundamental to the development and understanding of various mathematical disciplines.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"In modern mathematics, set theory's influence is all-encompassing. It is the framework within which most mathematical concepts and theories are formulated and discussed. From the abstract structures in algebra to the nuanced concepts in topology and analysis, set theory provides the essential vocabulary and syntax. It underpins the formation of groups, rings, and fields in algebra, the characterization of space in topology, and the rigorous foundation of calculus in analysis. This universality showcases set theory as not just a branch of mathematics but as the foundational dialect through which mathematics expresses itself.","category":"page"},{"location":"#Sets-in-Programming","page":"SetBuilders Documentation","title":"Sets in Programming","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"In programming languages like Julia and C++, the set data structure serves a specific yet crucial function, primarily focused on managing collections of unique elements. For instance, in Julia, converting an array to a set to eliminate duplicates is straightforward: my_set = Set(my_array). In C++, the Standard Template Library (STL) provides a set container that automatically removes duplicates and maintains element order, instantiated with std::set<int> my_set(my_array, my_array + array_size);.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, the application of sets in programming languages is more limited compared to their comprehensive role in mathematics. In mathematics, set theory is a fundamental discipline with wide-ranging implications. In contrast, programming primarily utilizes sets for pragmatic tasks like data manipulation and storage. While indispensable within their scope, these uses do not capture the broad and abstract nature of mathematical set theory. Consequently, sets in programming, despite their utility, represent a more confined aspect of the extensive and foundational role they play in mathematics.","category":"page"},{"location":"#[SetBuilders](https://github.com/grnydawn/SetBuilders.jl):-Harnessing-the-Power-of-Predicate-Based-Sets","page":"SetBuilders Documentation","title":"SetBuilders: Harnessing the Power of Predicate-Based Sets","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set, vital in math, finds new life in programming with Julia's SetBuilders. This tool innovatively allows sets to be defined not just by listing elements but also through predicates - logical formulas yielding true for set members. Predicates in Julia can be any expression yielding a Boolean result, thus enabling sophisticated set definitions through set operations. Additionally, SetBuilders offers features such as set event and customizable set descriptions, greatly enhancing its utility.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"# continues from the code example at the beginning of this page\n\nF = hist -> println(describe(hist[1].set, mark=hist[end].set))\nismember(1, C, on_nomember=F)","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The above example demonstrates how to identify the set that fails the membership test among the sets in the set composition using set event and set description features.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The value 1 is not a member of set C because the predicate of set B excludes it. The following output from the previous code indicates that the \"=>\" mark correctly identifies set B as the reason for exclusion.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"{ x ∈ A | 0 < x < 4 }, where\n    A = { x ∈ ::Integer }\n∩\n => { x ∈ A | 1 < x < 5 }, where\n    A = { x ∈ ::Integer }","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The function ismember serves the same purpose as the membership operator, in or ∈, but with additional keyword arguments. In the example, on_nomember accepts a function with one input argument, hist, and prints the output from the describe function, which details the structure of the first argument's set. Optionally, the describe function accepts a mark keyword argument to highlight a specific set in the output. In this case, hist[end].set is the set that fails the membership test.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"For further details, please continue reading the following manual.","category":"page"},{"location":"#Contents","page":"SetBuilders Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set Creation: explains how to use @setbuild macro for building various types of sets.\nSet Operations: shows examples of using set operations.\nSet Description: explains how to generate set descriptions.\nSet Event: explains how to use set event with a callback function\nSet Element Generation: explains how to generate set elements from Mapped sets.\nSet Sharing: explains how to create/use/share a Julia module for sets\nReference: provides reference manual for using SetBuilders.","category":"page"},{"location":"operations/#Set-Operations","page":"Set Operations","title":"Set Operations","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"SetBuilders sets support conventional set operations including union, intersection, difference, symmetric difference, and complement.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"To support examples in this page, the following sets are pre-built. To learn how to use @setbuild for the following set creations, see Set Creation.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"I = @setbuild(Integer)\nA = @setbuild(x in I, 0 <= x < 10)\nB = @setbuild(x in I, 5 <= x < 15)\nX = @setbuild(Union{Int64, Int32}[Int32(-1), Int32(1), 2])","category":"page"},{"location":"operations/#Union","page":"Set Operations","title":"Union","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function union or the set operator ∪ performs set union.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 0 in union(A, B)    # 0 is a member of set A\n@assert 14 in A ∪ B         # 14 is a member of set B\n@assert !(-1 in A ∪ B)      # -1 is not a member of either set A or set B","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"All of the @assert checks in this page should pass.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"note: Note\nThe number of set arguments can be more than two. For example, union(A, B, X) is allowed. \"A ∪ B ∪ X\" is same to \"union(A, B, X)\".This applies to other set operations including intersection, set difference, and set symmetric difference.","category":"page"},{"location":"operations/#Intersection","page":"Set Operations","title":"Intersection","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function intersect or the set operator ∩ performs set intersection.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 5 in intersect(A, B)    # 5 is a member of both set A and set B\n@assert 9 in A ∩ B              # 9 is a member of both set A and set B\n@assert !(0 in A ∩ B)           # 0 is a member of set A, but not of set B","category":"page"},{"location":"operations/#Difference","page":"Set Operations","title":"Difference","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function setdiff or the set operator - performs set difference.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 0 in setdiff(A, B)      # 0 is a member of set A, but not of set B\n@assert 4 in A - B              # 4 is a member of set A, but not of set B\n@assert !(5 in A - B)           # 5 is a member of both set A and set B","category":"page"},{"location":"operations/#Symmetric-Difference","page":"Set Operations","title":"Symmetric Difference","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function symdiff performs set symmetric difference.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 0  in symdiff(A, B)     # 0 is a member of set A, but not of set B\n@assert 10 in symdiff(A, B)     # 10 is a member of set B, but not of set A\n@assert !(5 in symdiff(A, B))   # 5 is a member of both set A and set B","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"note: Note\nWhere there are more than two set arguments, the symmetric difference operation is applied as a binary operation with the result of the previous operation. For example, symdiff(A, B, X) is evaluated as symdiff(symdiff(A, B), X).","category":"page"},{"location":"operations/#Complement","page":"Set Operations","title":"Complement","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function complement or the set operator ~ performs set complement.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"A = @setbuild(x in I, 0 <= x < 10)\n\n@assert 10 in complement(A)     # 10 is not a member of set A\n!assert !(1 in ~A)              # 1 is a member of set A\n@assert 1 in ~complement(A)     # double complements cancel each other out","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"Also, note that the complement of the EmptySet is the UniversalSet, and vice versa.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"E = @setbuild()\nU = @setbuild(Any)\n\n@assert complement(E) == U\n@assert complement(U) == E\n@assert ~U == E\n@assert ~E == U","category":"page"}]
}
