var documenterSearchIndex = {"docs":
[{"location":"description/#Set-Description","page":"Set Description","title":"Set Description","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"This segment concentrates on generating detailed set descriptions. Combined with set events, these descriptions are essential for intuitively comprehending the reasons behind set membership outcomes in complex situations. Using \"println(describe(C))\" displays the details of set C's construction.:","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ A | 0 < x < 4 }, where\n    A = { x ∈ ::Integer }\n∩\n{ x ∈ A | 1 < x < 5 }, where\n    A = { x ∈ ::Integer }","category":"page"},{"location":"creation/#Set-Creation","page":"Set Creation","title":"Set Creation","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"This part demonstrates the \"@setbuild\" macro in SetBuilders for creating sets from Julia data types, predicates, and mappings. For example, I = @setbuild(Integer) creates a set of all Julia Integer type objects, and A = @setbuild(x ∈ I, 0 < x < 4) creates a set that implies to contain the integers 1, 2, and 3.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Here are examples of set creations:","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"# Test fixtures\nvalue = 10\n\nstruct MyStruct\n    a\n    b\nend\n\nfunction myfunc(x)\n    x - 5\nend\n\n# Empty set\nE = @setbuild()\n\n# Universal set\nU = @setbuild(Any)\n\n# sets from Julia types\nI = @setbuild(Integer)\nR = @setbuild(Real)\nS = @setbuild(MyStruct)\n\n# Partially enumerable sets\nA = @setbuild([1, 2, 3])\nB = @setbuild(Int64[value, 2])\nC = @setbuild(Dict{String, String}[])\n\n# Cartesian sets\nD = @setbuild((I, I))\nF = @setbuild((x, y) in I)\nG = @setbuild((I^3, z in I))\n\n# Predicate sets\nH = @setbuild(x in I, 0 <= x < 10)\nJ = @setbuild(x in I, 5 <= x < 15)\nK = @setbuild((x in H, y in J), x < 5 && y > 10)\nL = @setbuild((x in H, y in J), c1*x + c2*y > 0, c1=-1, c2=1)\nM = @setbuild(x in I, x + y > 0, y=value)\nN = @setbuild(x in @setbuild(Real), x > 0)\n\n# Mapped sets\nO = @setbuild(z in I, (x in H) -> x + 5, z -> z - 5)\nP = @setbuild(z in I, (x in J) -> x + 5, z -> func(z), func=myfunc)\nQ = @setbuild(z in S, (x in H, y in J) -> mystruct(x, y),\n                z -> (z.a, z.b), mystruct=MyStruct)","category":"page"},{"location":"event/#Membership-Event","page":"Membership Event","title":"Membership Event","text":"","category":"section"},{"location":"event/","page":"Membership Event","title":"Membership Event","text":"This section introduces event handlers that activate in response to the outcomes of membership tests and their applications in different scenarios. For example, using ","category":"page"},{"location":"event/","page":"Membership Event","title":"Membership Event","text":"julia> F = hist -> println(describe(hist[1].set, mark=hist[end].set))\n#1 (generic function with 1 method)\n\njulia> is_member(C, 1, on_notamember=F)\nfalse","category":"page"},{"location":"event/","page":"Membership Event","title":"Membership Event","text":"displays the details of set C's construction, pinpointing the specific set that failed the membership test.","category":"page"},{"location":"event/","page":"Membership Event","title":"Membership Event","text":"{ x ∈ A | 0 < x < 4 }, where\n    A = { x ∈ ::Integer }\n∩\n => { x ∈ A | 1 < x < 5 }, where\n    A = { x ∈ ::Integer }","category":"page"},{"location":"sharing/#Set-Sharing","page":"Set Sharing","title":"Set Sharing","text":"","category":"section"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"Introduces a Julia module extension for creating, saving, and sharing sets as files to facilitate collaboration among users.","category":"page"},{"location":"mapping/#Element-Mappings","page":"Element Mappings","title":"Element Mappings","text":"","category":"section"},{"location":"mapping/","page":"Element Mappings","title":"Element Mappings","text":"MappedSet contains a map that associates each element in the domain with zero or more elements in the codomain, known as a forward map. It also includes a backward map for reverse mapping. Elements can be generated using these maps.","category":"page"},{"location":"developer/#Developer-Documentaion","page":"Developer Documentation","title":"Developer Documentaion","text":"","category":"section"},{"location":"developer/#Extending-SetBuilders","page":"Developer Documentation","title":"Extending SetBuilders","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SetBuilders]\nPrivate = false","category":"page"},{"location":"reference/#SetBuilders.SetBuilders","page":"Reference","title":"SetBuilders.SetBuilders","text":"Main module for SetBuilders.jl – predicate-based set generation package for Julia.\n\n\n\n\n\n","category":"module"},{"location":"reference/#SetBuilders.SBSet","page":"Reference","title":"SetBuilders.SBSet","text":"SBSet - Type\n\nThe SBSet type is the supertype of all SetBuilders set types.\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> I isa SBSet\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.CompositeSet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::CompositeSet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> A = @setbuild(x in I, 0 <= x < 10)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> B = @setbuild(x in I, 5 <= x < 15)\nPredicateSet((x ∈ TypeSet(Integer)) where 5 <= x < 15)\n\njulia> C = A ∩ B\nCompositeSet(PredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10) ∩ PredicateSet((x ∈ TypeSet(Integer)) where 5 <= x < 15))\n\njulia> is_member(C, 5) # 5 in C\ntrue\n\njulia> is_member(C, 0) # 0 in C\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.EmptySet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::EmptySet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> E = @setbuild()\nEmptySet()\n\njulia> is_member(E, 1)   # 1 in E\nfalse\n\njulia> is_member(E, 0.1) # 0.1 in E\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.EnumerableSet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::EnumerableSet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> A = @setbuild(Union{Int64, Float64}[1])\nEnumerableSet([{Float64}*0, {Int64}*1])\n\njulia> is_member(A, 1)\ntrue\n\njulia> is_member(A, Int32(1))\nfalse\n\njulia> push!(A, Float64(2.0))\nEnumerableSet([{Float64}*1, {Int64}*1])\n\njulia> is_member(A, Float64(2.0))\ntrue\n\njulia> pop!(A, Float64(2.0))\n2.0\n\njulia> is_member(A, Float64(2.0))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.MappedSet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::MappedSet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> struct MyStruct\n       a\n       b\n       end\n\njulia> S = @setbuild(MyStruct)\nTypeSet(MyStruct)\n\njulia> A = @setbuild(s in S, (x in I, y in I) -> mystruct(x,y), s -> (s.a, s.b),\n                     mystruct=MyStruct)\nMappedSet((x ∈ TypeSet(Integer)), (y ∈ TypeSet(Integer)) -> (s ∈ TypeSet(MyStruct)))\n\njulia> is_member(A, MyStruct(1, 1))   # MyStruct(1, 1) in A\ntrue\n\njulia> is_member(A, MyStruct(1.0, 1)) # MyStruct(1.0, 1) in A\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.PredicateSet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::PredicateSet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> A = @setbuild(x in I, 0 <= x < 10)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> is_member(A, 0)  # 0 in A \ntrue\n\njulia> is_member(A, 10) # 10 in A\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.TypeSet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::TypeSet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> is_member(I, 1)   # 1 in I\ntrue\n\njulia> is_member(I, 0.1) # 0.1 in I\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.is_member-Tuple{SetBuilders.UniversalSet, Any}","page":"Reference","title":"SetBuilders.is_member","text":"is_member(set::UniversalSet, elem; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> U = @setbuild(Any)\nUniversalSet()\n\njulia> is_member(U, 1)   # 1 in U\ntrue\n\njulia> is_member(U, 0.1) # 0.1 in U\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.@setbuild-Tuple","page":"Reference","title":"SetBuilders.@setbuild","text":"@setbuild([args...[; kwargs...]])\n\nThe @setbuild macro creates various SetBuilders sets.\n\nThe @setbuild macro in SetBuilders for creating sets from Julia data types, predicates, and mappings. For example, I = @setbuild(Integer) creates a set of all Julia Integer type objects, and A = @setbuild(x ∈ I, 0 < x < 4) creates a set that implies to contain the integers 1, 2, and 3.\n\nExamples\n\njulia> E = @setbuild()\nEmptySet()\n\njulia> U = @setbuild(Any)\nUniversalSet()\n\njulia> I = @setbuild(Integer) # Julia Integer-type set\nTypeSet(Integer)\n\njulia> D = @setbuild(Dict{String, Number}) # Julia Dict{String, Number}-type set\nTypeSet(Dict{String, Number})\n\njulia> struct MyStruct\n           a\n           b\n       end\n\njulia> S = @setbuild(MyStruct)  # Julia user-type set\nTypeSet(MyStruct)\n\njulia> N = @setbuild([1, 2, 3]) # Enumerable set\nEnumerableSet([{Int64}*3])\n\njulia> C = @setbuild((I, I))  # Cartesian sets\nPredicateSet((c1 ∈ TypeSet(Integer)), (c2 ∈ TypeSet(Integer)) where true)\n\njulia> P = @setbuild(x in I, 0 <= x < 10) # Predicate sets\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> M = @setbuild(z in I, (x in P) -> x + 5, z -> z - 5) # Mapped sets\nMappedSet((x ∈ PredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)) -> (z ∈ TypeSet(Integer)))\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SetBuilders.@setpkg-Tuple","page":"Reference","title":"SetBuilders.@setpkg","text":"@setpkg command[ command-arguments... ]\n\nThe @setpkg macro enables the reuse of sets that were developed separately.\n\ncommands\n\nload: loads sets from a local file, also known as a setfile\n\n@setpkg load <path/to/file>\n\nThe setfile is a regular Julia module customized for SetBuilders.\n\nExamples\n\nAssuming that the file myset.sjl contains the following Julia code:\n\nmodule MySetModule\n\nexport MYSET\n\nI = @setbuild(Integer)\nMYSET = @setbuild(x in I, x > 0)\n\nend\n\nMYSET can be used as shown in the example below:\n\njulia> @setpkg load \"myset.sjl\"\n\njulia> using SetBuilders.MySetModule\n\njulia> 1 in MYSET\ntrue\n\njulia> 0 in MYSET\nfalse\n\n\n\n\n\n","category":"macro"},{"location":"membership/#Set-Membership","page":"Set Membership","title":"Set Membership","text":"","category":"section"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"This section explains set membership checks using operators such as \"in\" or \"∈\". In the previous example, \"1 in A\" would return \"true\", whereas \"4 ∈ A\" would yield \"false\".","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"Once a set is created, checking if an object is a member of the set is straightforward using the in or ∈ operators.","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"All of the following @assert checks should pass.","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"# Empty set\nE = @setbuild()\n@assert !(1 in E)\n\n# Universal set\nU = @setbuild(Any)\n@assert 1 in U\n\n# sets from Julia types\nI = @setbuild(Integer)\n@assert 1 in I\n@assert !(1.0 in I)\n\nR = @setbuild(Real)\n@assert 1.0 in R\n@assert !(1.0im in R)\n\nS = @setbuild(MyStruct)\n@assert MyStruct(1,2) in S\n@assert !(1 in S)\n\n# Partially enumeratable sets\nA = @setbuild([1, 2, 3])\n@assert 1 in A\n@assert !(4 in A)\n\nB = @setbuild(Int64[value, 2])\n@assert value in B\n@assert !(Int32(value) in B)\n@assert !(3 in B)\npush!(B, 3)\n@assert 3 in B\npop!(B, 3)\n@assert !(3 in B)\n\nC = @setbuild(Dict{String, String}[])\nd1 = Dict{String, String}(\"a\" => \"x\")\nd2 = Dict{String, Integer}(\"a\" => 1)\n@assert !(d1 in C)\npush!(C, d1)\n@assert d1 in C\n@assert !(d2 in C)\n\n# Cartesian sets\nD = @setbuild((I, I))\n@assert (1, 1) in D\n@assert !(1 in D)\n@assert !((1.0, 1.0) in D)\n\nF = @setbuild((x, y) in I)\n@assert (1, 1) in F\n@assert !(1 in F)\n@assert !((1.0, 1.0) in F)\n\nG = @setbuild((I^3, z in I))\n@assert (1, 1, 1, 1) in G\n@assert !(1 in G)\n@assert !((1.0, 1.0, 1.0, 1.0) in G)\n\n# Predicate sets\nH = @setbuild(x in I, 0 <= x < 10)\n@assert 0 in H\n@assert !(10 in H)\n\nJ = @setbuild(x in I, 5 <= x < 15)\n@assert 5 in J\n@assert !(15 in J)\n\nK = @setbuild((x in H, y in J), x < 5 && y > 10)\n@assert (4, 11) in K\n@assert !((9, 10) in K)\n\nL = @setbuild((x in H, y in J), c1*x + c2*y > 0, c1=-1, c2=1)\n@assert (5, 10) in L\n@assert !((9, 5) in L)\n\nM = @setbuild(x in I, x + y > 0, y=value)\n@assert -9 in M\n@assert !(-10 in M)\n\nN = @setbuild(x in @setbuild(Real), x > 0)\n@assert 1 in N\n@assert 1.0 in N\n@assert !(1im in N)\n\n# Mapped sets\nO = @setbuild(z in I, (x in H) -> x + 5, z -> z - 5)\n@assert 5 in O\n@assert !(0 in O)\n\nP = @setbuild(z in I, (x in J) -> x + 5, z -> func(z), func=myfunc)\n@assert 10 in P\n@assert !(5 in P)\n\nQ = @setbuild(z in S, (x in H, y in J) -> mystruct(x, y),\n                z -> (z.a, z.b), mystruct=MyStruct)\n@assert MyStruct(5, 5) in Q\n@assert !(MyStruct(10, 10) in Q)\n","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"CurrentModule = SetBuilders","category":"page"},{"location":"#SetBuilders","page":"SetBuilders Documentation","title":"SetBuilders","text":"","category":"section"},{"location":"#In-a-nutshell...","page":"SetBuilders Documentation","title":"In a nutshell...","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"SetBuilders provides Julia users with the power of predicate-based sets.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Many programming languages, including Julia, support a type of enumerable sets but not predicate sets in the mathematical sense. For instance, in Julia, it's possible to create a set containing integer values, such as","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set([1,2,3])","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, creating the following is not possible:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set(x ∈ Integer | 0 < x < 4)","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"With the SetBuilders package, Julia users can create predicate sets, compose them using set operations such as unions and intersections, and check if an object is a member of the set.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"I = @setbuild(Integer)           # creates a set from Julia Integer type\nA = @setbuild(x ∈  I, 0 < x < 4) # creates a set with the predicate of \"0 < x < 4\"\nB = @setbuild(x in I, 2 < x < 6) # creates a set with the predicate of \"2 < x < 6\"\nC = A ∩ B                        # creates an intersection with the two sets\n@assert 3 ∈ C                    # => true, 3 is a member of the set C\n@assert !(4 in C)                # => true, 4 is not a member of the set C","category":"page"},{"location":"#Sets-in-Mathematics","page":"SetBuilders Documentation","title":"Sets in Mathematics","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set theory, established by Georg Cantor in the late 19th century, is often regarded as the language of mathematics. It introduces the concept of a set as a collection of distinct objects and provides basic operations such as union, intersection, and difference. The evolution of set theory, marked by milestones like Cantor's work, Russell's Paradox, and the development of the Zermelo-Fraenkel Set Theory (ZF), has shaped it into a robust, axiomatic framework. This transformation solidified set theory's role as the universal language for expressing and structuring mathematical ideas, making it fundamental to the development and understanding of various mathematical disciplines.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"In modern mathematics, set theory's influence is all-encompassing. It is the framework within which most mathematical concepts and theories are formulated and discussed. From the abstract structures in algebra to the nuanced concepts in topology and analysis, set theory provides the essential vocabulary and syntax. It underpins the formation of groups, rings, and fields in algebra, the characterization of space in topology, and the rigorous foundation of calculus in analysis. This universality showcases set theory as not just a branch of mathematics but as the foundational dialect through which mathematics expresses itself.","category":"page"},{"location":"#Sets-in-Programming","page":"SetBuilders Documentation","title":"Sets in Programming","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"In programming languages like Julia and C++, the set data structure serves a specific yet crucial function, primarily focused on managing collections of unique elements. For instance, in Julia, converting an array to a set to eliminate duplicates is straightforward: my_set = Set(my_array). In C++, the Standard Template Library (STL) provides a set container that automatically removes duplicates and maintains element order, instantiated with std::set<int> my_set(my_array, my_array + array_size);.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, the application of sets in programming languages is more limited compared to their comprehensive role in mathematics. In mathematics, set theory is a fundamental discipline with wide-ranging implications. In contrast, programming primarily utilizes sets for pragmatic tasks like data manipulation and storage. While indispensable within their scope, these uses do not capture the broad and abstract nature of mathematical set theory. Consequently, sets in programming, despite their utility, represent a more confined aspect of the extensive and foundational role they play in mathematics.","category":"page"},{"location":"#SetBuilders:-Harnessing-the-Power-of-Predicate-Based-Sets","page":"SetBuilders Documentation","title":"SetBuilders: Harnessing the Power of Predicate-Based Sets","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set, vital in math, finds new life in programming with Julia's SetBuilders. This tool innovatively allows sets to be defined not just by listing elements but also through predicates - logical formulas yielding true for set members. Predicates in Julia can be any expression yielding a Boolean result, thus enabling sophisticated set definitions through set operations. Additionally, SetBuilders offers features such as event handlers and customizable set descriptions, greatly enhancing its utility.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Many programming languages, including Julia, support a type of enumerable sets but not predicate sets in the mathematical sense. For instance, in Julia, it's possible to create a set containing integer values, such as","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set([1,2,3])","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, creating the following is not possible:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set(x ∈ Integer | 0 < x < 4)","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"With the SetBuilders package, Julia users can create predicate sets, compose them using set operations such as unions and intersections, and check if an object is a member of the set.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"I = @setbuild(Integer)           # creates a set from Julia Integer type\nA = @setbuild(x ∈  I, 0 < x < 4) # creates a set with the predicate of \"0 < x < 4\"\nB = @setbuild(x in I, 2 < x < 6) # creates a set with the predicate of \"2 < x < 6\"\nC = A ∩ B                        # creates an intersection with the two sets\n@assert 3 ∈ C                    # => true, 3 is a member of the set C\n@assert !(4 in C)                # => true, 4 is not a member of the set C","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"SetBuilders Usage","category":"page"},{"location":"#Contents","page":"SetBuilders Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"SetBuilders Github Repository: .","category":"page"},{"location":"operations/#Set-Operations","page":"Set Operations","title":"Set Operations","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"It explores conventional set operations like union, intersection, difference, symmetric difference, and complement. If B = @setbuild(x ∈ I, 1 < x < 5), then creating an intersection C = A ∩ B would result in 2 in C being true, but 1 in C false.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"E = @setbuild()\nU = @setbuild(Any)\n\n@assert all(x -> !(x in E), (0, 1))\n@assert all(x -> x in U, (0, 1))\n\n@assert complement(E) == U\n@assert complement(U) == E\n@assert ~U == E\n@assert ~E == U\n\nI = @setbuild(Integer)\nA = @setbuild(x in I, 0 <= x < 10)\nB = @setbuild(x in I, 5 <= x < 15)\nX = @setbuild(Union{Int64, Int32}[Int32(-1), Int32(1), 2])\n\n@assert all(x -> x in A, 0:9)\n@assert all(x -> x ∈ A, 0:9)\n@assert all(x -> !(x in A), (-1, 10))\n\n@assert all(x -> x in union(A, B), 0:14)\n@assert all(x -> x in A ∪ B, 0:14)\n@assert all(x -> !(x in union(A, B)), (-1, 15))\n@assert all(x -> x in union(A, U), -1:15)\n@assert all(x -> x in A ∪ ~E, -1:15)\n@assert all(x -> x in union(A, E), 0:9)\n\n@assert all(x -> x in intersect(A, B), 5:9)\n@assert all(x -> x ∈ A ∩ B, 5:9)\n@assert all(x -> !(x in intersect(A, B)), 0:4)\n@assert all(x -> x in intersect(A, U), 0:9)\n@assert all(x -> !(x in intersect(A, E)), -1:15)\n\n@assert all(x -> x in setdiff(A, B), 0:4)\n@assert all(x -> x in A - B, 0:4)\n@assert all(x -> !(x in setdiff(A, B)), 5:9)\n@assert all(x -> !(x in setdiff(A, U)), -1:15)\n@assert all(x -> x in setdiff(U, A), 10:14)\n@assert all(x -> x in ~E - A, 10:14)\n@assert all(x -> x in setdiff(A, E), 0:9)\n@assert all(x -> !(x in setdiff(E, A)), -1:15)\n\n@assert all(x -> x in symdiff(A, B), [0:4; 10:14])\n@assert all(x -> !(x in symdiff(A, B)), 5:9)\n@assert all(x -> !(x in symdiff(A, U)), 0:9)\n@assert all(x -> x in symdiff(A, E), 0:9)\n\n@assert all(x -> x in A ∪ X, [Int32(i) for i in -1:9])\n@assert all(x -> !(x in A ∩ X), [0, 1])","category":"page"}]
}
