var documenterSearchIndex = {"docs":
[{"location":"description/#Set-Description","page":"Set Description","title":"Set Description","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"This section introduces on generating detailed set descriptions. ","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The format of set description is drawn from the set-builder notation in mathematics, like '{ x ∈ R | 0 < x < 4 }'.","category":"page"},{"location":"description/#Sets-from-Julia-types","page":"Set Description","title":"Sets from Julia types","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"I = @setbuild(Integer)\n\nprintln(describe(I))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Overall, the description is similar to the set-builder notation. The double colon indicates of Julia type.","category":"page"},{"location":"description/#Enumerable-Set","page":"Set Description","title":"Enumerable Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"E1 = @setbuild([1, 2, 3])\n\nprintln(describe(E1))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ ::Int64*3 }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"In addition to the output seen with a set with Julia type, the *3 indicates that the set is EnumerableSet and the number of elements in the set is 3.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"E2 = @setbuild(Union{Int64, Float64}[1, 2, 3.0])\n\nprintln(describe(E2))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ (::Float64*1, ::Int64*2) }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The tuple indicates that the set E2 can have members of the Float64 or Int64 types, and the number of elements is 1 and 2, respectively.","category":"page"},{"location":"description/#Cartesian-Set","page":"Set Description","title":"Cartesian Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"C = @setbuild((I, I))\n\nprintln(describe(C))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ c1 ∈ A, c2 ∈ B }, where\n    A = { x ∈ ::Integer }\n    B = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The members of the cartesian set C are pairs of two elements from set I. The c1 and c2 set variables and set names of A and B are automatically created by SetBuilders. The set A is the first set and B is the second set in the original cartesian set definition.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Each set A and set B are futher described with indentation.","category":"page"},{"location":"description/#Predicate-Set","page":"Set Description","title":"Predicate Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"P1 = @setbuild(x in I, 0 <= x < 10)\n\nprintln(describe(P1))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ A | 0 <= x < 10 }, where\n    A = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The left side of the vertical bar represents the set variable part, and the right side represents the predicate part.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"P2 = @setbuild(x in I, 5 <= x < 15)\nP3 = @setbuild((x in P1, y in P2), x < 5 && y > 10)\n\nprintln(describe(P3))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"{ x ∈ A, y ∈ B | x < 5 && y > 10 }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n        A.A = { x ∈ ::Integer }\n    B = { x ∈ B.A | 5 <= x < 15 }, where\n        B.A = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The output indicates that the members of set P3 are pairs of elements, each from sets A and B, with the predicates 'x < 5 && y > 10'. The members of sets A and B are Julia Integer values, each with the predicates '0 <= x < 10' and '5 <= x < 15', respectively. To indicate the hierarchy of sets, a dot ('.') is inserted between the capital letters, such as 'A.A'. The capital letter progresses from A to Z and starts again from A if the number of sets exceeds the number of alphabets such as \"AA.A\".","category":"page"},{"location":"description/#Mapped-Set","page":"Set Description","title":"Mapped Set","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"M1 = @setbuild(x in P1, z in I, z = x + 5, x = z - 5)\n\nprintln(describe(M1))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The above code prints the following output on screen.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n        A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n    B = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The first set description at the top of the output is the source set of the 'forward mapping', denoted as 'F-MAP'. Right below the forward mapping arrow is the destination set. 'B-MAP' indicates 'backward mapping' from the destination set to the source set.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"With indentation, the sets and mappings used in the construction of MappedSet are further described.","category":"page"},{"location":"description/#Marking-a-set-in-description","page":"Set Description","title":"Marking a set in description","text":"","category":"section"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Set operations and mappings make it easy to build a new set from multiple sets. Therefore, we can conveniently and systematically describe a complex condition using a set or a composite of sets generated from set operations and mappings.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"However, as the number of sets involved in describing a condition increases, analyzing the structure and relationships between the sets becomes more challenging.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"The describe function features a way to mark a specific set that is part of a larger set, enabling users to easily pinpoint a specific set for a certain purpose.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"In previous examples, set M1 uses sets P1 and I, and set P1 uses set I. Assuming we want to know all the cases in which set I is used in set M1, we can use the describe function as follows:","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"println(describe(M1, mark=I))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"produces","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n     => A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n => B = { x ∈ ::Integer }","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"Note that there are two positions where set I is being used pointed by \"=>\" mark.","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"In case that a different mark is preferred, we can use a tuple with a new mark as following:","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"println(describe(M1, mark=(I, \"## \")))","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"produces","category":"page"},{"location":"description/","page":"Set Description","title":"Set Description","text":"\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n    A = { x ∈ A.A | 0 <= x < 10 }, where\n     ## A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n ## B = { x ∈ ::Integer }","category":"page"},{"location":"creation/#Set-Creation","page":"Set Creation","title":"Set Creation","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The @setbuild macro in SetBuilders is the primary interface for creating sets.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With this macro, users can create sets from Julia types, predicates, mappings, and lists of elements.","category":"page"},{"location":"creation/#Empty-Set-and-Universal-Set","page":"Set Creation","title":"Empty Set and Universal Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Let's start with the simplest ones: the empty set and the universal set.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"E = @setbuild()     # Empty set\nU = @setbuild(Any)  # Universal set\n\n@assert !(1 in E)   # No elements in EmptySet\n@assert 1 in U      # Any element is a member of UniversalSet","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With no argument, @setbuild creates an empty set, which does not contain any elements. All membership tests with EmptySet returns Boolean false.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"note: Note\nAll @assert tests in the examples of this page should pass.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"In Julia, the Any type is a special type that sits at the top of the type hierarchy. With the Any type, @setbuild creates the universal set, which includes all objects in Julia. All membership tests with EmptySet returns Boolean true.","category":"page"},{"location":"creation/#Set-from-Julia-Types","page":"Set Creation","title":"Set from Julia Types","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With Jula type, @setbuild creates a set that includes all instances of that type.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"I = @setbuild(Integer)\n\n@assert 1 in I              # 1 is one instance of Integer subtype\n@assert !(1.0 in I)         # 1.0 is one instance of Real subtype, not Integer subtype","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set I includes instances of all subtypes of Integer (BigInt, Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8, and Bool).","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Please note that the set I \"conceptually includes\" such elements, but does not actually \"contain\" them. The membership evaluation is performed \"lazily\" at the time of checking.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"R = @setbuild(Real)\n\n@assert 1.0 in R            # 1 is one instance of Real subtype\n@assert !(1.0im in R)       # 1.0im is one instance of Complex type, not Real subtype","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Similarly, the set R includes all instances of all subtypes of the Real type, encompassing all subtypes of Integer, AbstractFloat, AbstractIrrational, and Rational types.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"struct MyStruct\n    a\n    b\nend\n\nS = @setbuild(MyStruct)\n\n@assert MyStruct(1,2) in S  # MyStruct(1,2) is one instance of MyStruct type\n@assert !(1 in S)           # 1 is not an instance of MyStruct type","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Note also that @setbuild can create sets from user-defined types. The set S includes all instances of the MyStruct type.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The following diagram depicts the three sets in the above example.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"(Image: Sets from Julia types)","category":"page"},{"location":"creation/#Enumerable-Set","page":"Set Creation","title":"Enumerable Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Similar to Julia's Set data structure, @setbuild can create a set from a list of elements.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The brackets([ and ] in the first @setbuild argument directs to build an enumerable set.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"A = @setbuild([1, 2, 3])\n\n@assert 1 in A      # 1 is one of the elements of set A\n@assert !(4 in A)   # 4 is not an element of set A","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set A in the above example is created with three elements.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Note that the Setbuilders Enumerable Set actually 'contains' the elements in the same way as the Set data structure in Julia.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"value = 10\n\nB = @setbuild(Int64[value, 2])\n\n@assert value in B              # `value` defined outside of `@setbuild` is used\n@assert !(Int32(value) in B)    # Set B can contain `Int64` type, not `Int32`\n@assert !(3 in B)               # 3 is not an element of set B\npush!(B, 3)                     # 3 is added into set B\n@assert 3 in B                  # Now, 3 is a member of set B\npop!(B, 3)                      # 3 is removed from set B\n@assert !(3 in B)               # 3 is not a member of set B","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Users can specify the type of elements, as shown in the set B. There is one difference in handling the type of elements compared to Julia's Set. When an element is \"pushed\" into the set, SetBuilder enumerable sets do not promote the element's type, whereas Julia Set does.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The above example demonstrates how to add and remove an element to/from an EnumerableSet using the push! and pop! functions, similar to the Set in Julia.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"C = @setbuild(Dict{String, String}[])\n\nd1 = Dict{String, String}(\"a\" => \"x\")\nd2 = Dict{String, Integer}(\"a\" => 1)\n@assert !(d1 in C)                  # d1 is not a member of set C\npush!(C, d1)                        # d1 is added to set C\n@assert d1 in C                     # d1 is a member of set C\npush!(C, d2)                        # d2 can not be \"pushed\" to set C, due to type-mismatch\nERROR: push! failed due to element type mismatch: Dict{String, Integer} not in \nataType[Dict{String, String}].\n@assert !(d2 in C)                  # d2 is not a member of set C","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"EnumerableSet can accept instances of all Julia types as a member. Set C in the above example accepts a dictionary data structure with String key and String value. Note that the square brackets in the @setbuild arguement indicates for creation of an EnumerableSet.","category":"page"},{"location":"creation/#Cartesian-Product-Set","page":"Set Creation","title":"Cartesian Product Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"In some cases, we may want to create a set by selecting elements from each set and arranging the chosen elements in order, known as the Cartesian product.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"D = @setbuild((I, I))","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set D includes all pairs of elements from the set I, previously defined in the example above as a set of Julia Integer type.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"F = @setbuild((x, y) in I)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set F offers another syntax for creating a set of Integer pairs, similar to the set D.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"G = @setbuild((I^3, z in I))","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set G demonstrates another syntax for creating a Cartesian product set with the 4-ary Cartesian product set.","category":"page"},{"location":"creation/#Predicate-Set","page":"Set Creation","title":"Predicate Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Predicates are logical formulas that yield true for set members. In SetBuilders, predicates can be any expressions yielding a Boolean result, including functions.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"H = @setbuild(x in I, 0 <= x < 10)\n\n@assert 0 in H\n@assert !(10 in H)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set H in the above example has two arguments. The first argument defines the domain of the sets. In other words, all members of the set H should also be members of the set I, defined as an Integer set. Additionally, all members of these sets should satisfy the Boolean expression of the second argument.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The following diagram depicts the relation between the domain set I and the predicate set H.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"(Image: Predicate set)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"K = @setbuild((x in H, y in J), x < 5 && y > 10)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set K demonstrates how to define the domain of a set using multiple sets.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"L = @setbuild((x in H, y in J), c1*x + c2*y > 0, c1=-1, c2=1)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set L shows how to use values defined outside of the @setbuild macro.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"N = @setbuild(x in @setbuild(Real), x > 0)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set N illustrates that the @setbuild macro can be nested within another @setbuild macro.","category":"page"},{"location":"creation/#Mapped-Set","page":"Set Creation","title":"Mapped Set","text":"","category":"section"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"With a Mapped Set, users can create a set using mappings from one set to another.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"O = @setbuild(x in H, z in I, z = x + 5, x = z - 5)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"A \"Mapped Set\" should have at least four arguments.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The first argument defines the source set, or domain in mathematical term, of a mapping. The mapping starts from the elements of the set H.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The second argument defines the destination set , or codomain, of a mapping. The mapping arrives at the elements of the set I.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The third argument defines a \"forward\" mapping from the source set (H, domain) to the destination set (I, codomain). The mapping at the third argument defines the way how to generated an element(or elements) in the codomain.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The fourth argument defines a \"backward\" mapping from the destination set (I, codomain) to the source set (H, domain). The mapping at the fourth argument defines the way how to generated an element(or elements) in the domain.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"(Image: Mapping in the set O)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"function myfunc(x)\n    x - 5\nend\n\nP = @setbuild(x in J, z in I, z = x + 5, x = func(z), func=myfunc)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set P demonstrates how to use a function defined outside of @setbuild to create a mapping.","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"Q = @setbuild((x in H, y in J), z in S, z = mystruct(x, y),\n                (x, y) = (z.a, z.b), mystruct=MyStruct)","category":"page"},{"location":"creation/","page":"Set Creation","title":"Set Creation","text":"The set Q shows that a mapped set can map to a user-defined type.","category":"page"},{"location":"event/#Set-Event","page":"Set Event","title":"Set Event","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"SetBuilders provides users with the capability to register callback functions, so they can be called when an event occurs during operation.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The situations in which an event occurs can vary. As of this writing, membership events are supported.","category":"page"},{"location":"event/#Membership-events","page":"Set Event","title":"Membership events","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Membership events occur during membership check using ismember functions.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Note that membership check operators of in or ∈ can not be used for event handling.","category":"page"},{"location":"event/#Creating-a-callback-function","page":"Set Event","title":"Creating a callback function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"When an event occurs, SetBuilders makes a call to the registered callback function with one argument that is a vector of named tuple(:set and :elem).","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Let's start by creating a callback function.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"function F1(history)\n    desc = describe(history[1].set, mark=history[end].set)\n    println(\"#############\")\n    println(\"Not a Member\")\n    println(\"-------------\")\n    println(desc)\n    println(\"-------------\")\n    println(\", because '$(history[end].elem)' is not a member of the set pointed by '=>'\")\n    println(\"#############\")\nend","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The function F1 takes one argument, history, which contains all the sets visited during the membership check and the elements used in these sets.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The first item in the vector is the tuple of the set specified as the first argument and the value as the second argument of the ismember function.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The last item in the vector is the tuple of the set and the element at the time the event occurred.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"To illustrate, we used the describe function with the mark keyword argument to mark the last visited set where the event occurred. See Marking a set in description for an explanation of how to use the mark keyword argument in the describe function.","category":"page"},{"location":"event/#Registering-a-callback-function","page":"Set Event","title":"Registering a callback function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"Once a callback function is created, registering it to the ismember function is straightforward.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"I = @setbuild(Integer)\nP1 = @setbuild(x in I, 0 <= x < 10)\nM1 = @setbuild(x in P1, z in I, z = x + 5, x = z - 5)\n\nismember(0, M1, on_nomember=F1)","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"To register a callback function when a membership failure event occurs, we used the on_nomember keyword argument. In the case of a membership success event, on_member is used.","category":"page"},{"location":"event/#Reading-output-from-the-callback-function","page":"Set Event","title":"Reading output from the callback function","text":"","category":"section"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The previous example produces:","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"#############\nNot a Member\n-------------\n\n{ x ∈ A }\n         /\\ B-MAP\n      || ||\nF-MAP \\/\n{ z ∈ B }, where\n => A = { x ∈ A.A | 0 <= x < 10 }, where\n        A.A = { x ∈ ::Integer }\n    F-MAP: z = x + 5\n    B-MAP: x = z - 5\n    B = { x ∈ ::Integer }\n-------------\n, because '-5' is not a member of the set pointed by '=>'\n#############\nfalse","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The output shows that the membership test failed at set A, originally named P1, because the value -5 is not a member of set P1.","category":"page"},{"location":"event/","page":"Set Event","title":"Set Event","text":"The value -5 was calculated using B-MAP from the original argument value of 0 to -5, using the formula x = z - 5.","category":"page"},{"location":"sharing/#Set-Sharing","page":"Set Sharing","title":"Set Sharing","text":"","category":"section"},{"location":"sharing/","page":"Set Sharing","title":"Set Sharing","text":"Introduces a Julia module extension for creating, saving, and sharing sets as files to facilitate collaboration among users.","category":"page"},{"location":"mapping/#Set-Element-Generation","page":"Set Element Generation","title":"Set Element Generation","text":"","category":"section"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"MappedSet contains mappings that associate each elements in the domain and the codomain. This page explains how to use the mappings to generate elements from one set to another.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"To demonstrate the forward and backward mappings, following sets are prepared.","category":"page"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"struct MyStruct\n    a\n    b\nend\n\nI  = @setbuild(Integer)\nM1 = @setbuild(\n        (x, y) in I,        # domain: a pair of integer values\n        z in S,             # codomain: an instance of MyStruct type\n        z = mystruct(x, y), # forward mapping: MyStruct z from the pair in the domain\n        (x, y) = (z.a, z.b),# backward mapping: The domain is recovered from MyStruct fields\n        mystruct=MyStruct   # Let SetBuilders know the name of mystruct\n    )","category":"page"},{"location":"mapping/#Forward-mapping","page":"Set Element Generation","title":"Forward mapping","text":"","category":"section"},{"location":"mapping/","page":"Set Element Generation","title":"Set Element Generation","text":"Forward mapping maps from the elements in the domain to the ones in codomain and backward mapping in reverse.","category":"page"},{"location":"developer/#Developer-Documentaion","page":"Developer Documentation","title":"Developer Documentaion","text":"","category":"section"},{"location":"developer/#Extending-SetBuilders","page":"Developer Documentation","title":"Extending SetBuilders","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SetBuilders]\nPrivate = false","category":"page"},{"location":"reference/#SetBuilders.SetBuilders","page":"Reference","title":"SetBuilders.SetBuilders","text":"Main module for SetBuilders.jl – predicate-based set generation package for Julia.\n\n\n\n\n\n","category":"module"},{"location":"reference/#SetBuilders.SBSet","page":"Reference","title":"SetBuilders.SBSet","text":"SBSet - Type\n\nThe SBSet type is the supertype of all SetBuilders set types.\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> I isa SBSet\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.CompositeSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::CompositeSet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> A = @setbuild(x in I, 0 <= x < 10)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> B = @setbuild(x in I, 5 <= x < 15)\nPredicateSet((x ∈ TypeSet(Integer)) where 5 <= x < 15)\n\njulia> C = A ∩ B\nCompositeSet(PredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10) ∩ PredicateSet((x ∈ TypeSet(Integer)) where 5 <= x < 15))\n\njulia> ismember(5, C) # 5 in C\ntrue\n\njulia> ismember(0, C) # 0 in C\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.EmptySet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::EmptySet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> E = @setbuild()\nEmptySet()\n\njulia> ismember(1, E)   # 1 in E\nfalse\n\njulia> ismember(0.1, E) # 0.1 in E\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.EnumerableSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::EnumerableSet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> A = @setbuild(Union{Int64, Float64}[1])\nEnumerableSet([{Float64}*0, {Int64}*1])\n\njulia> ismember(1, A)\ntrue\n\njulia> ismember(Int32(1), A)\nfalse\n\njulia> push!(A, Float64(2.0))\nEnumerableSet([{Float64}*1, {Int64}*1])\n\njulia> ismember(Float64(2.0), A)\ntrue\n\njulia> pop!(A, Float64(2.0))\n2.0\n\njulia> ismember(Float64(2.0), A)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.MappedSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::MappedSet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> struct MyStruct\n       a\n       b\n       end\n\njulia> S = @setbuild(MyStruct)\nTypeSet(MyStruct)\n\njulia> A = @setbuild(s in S, (x in I, y in I) -> mystruct(x,y), s -> (s.a, s.b),\n                     mystruct=MyStruct)\nMappedSet((x ∈ TypeSet(Integer)), (y ∈ TypeSet(Integer)) -> (s ∈ TypeSet(MyStruct)))\n\njulia> ismember(MyStruct(1, 1), A)   # MyStruct(1, 1) in A\ntrue\n\njulia> ismember(MyStruct(1.0, 1), A) # MyStruct(1.0, 1) in A\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.PredicateSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::PredicateSet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> A = @setbuild(x in I, 0 <= x < 10)\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> ismember(0, A)  # 0 in A \ntrue\n\njulia> ismember(10, A) # 10 in A\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.TypeSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::TypeSet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> I = @setbuild(Integer)\nTypeSet(Integer)\n\njulia> ismember(1, I)   # 1 in I\ntrue\n\njulia> ismember(0.1, I) # 0.1 in I\nfalse\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.ismember-Tuple{Any, SetBuilders.UniversalSet}","page":"Reference","title":"SetBuilders.ismember","text":"ismember(elem, set::UniversalSet; kwargs...)\n\nCheck if elem is a member of set\n\nExamples\n\njulia> U = @setbuild(Any)\nUniversalSet()\n\njulia> ismember(1, U)   # 1 in U\ntrue\n\njulia> ismember(0.1, U) # 0.1 in U\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#SetBuilders.@setbuild-Tuple","page":"Reference","title":"SetBuilders.@setbuild","text":"@setbuild([args...[; kwargs...]])\n\nThe @setbuild macro creates various SetBuilders sets.\n\nThe @setbuild macro in SetBuilders for creating sets from Julia data types, predicates, and mappings. For example, I = @setbuild(Integer) creates a set of all Julia Integer type objects, and A = @setbuild(x ∈ I, 0 < x < 4) creates a set that implies to contain the integers 1, 2, and 3.\n\nExamples\n\njulia> E = @setbuild()\nEmptySet()\n\njulia> U = @setbuild(Any)\nUniversalSet()\n\njulia> I = @setbuild(Integer) # Julia Integer-type set\nTypeSet(Integer)\n\njulia> D = @setbuild(Dict{String, Number}) # Julia Dict{String, Number}-type set\nTypeSet(Dict{String, Number})\n\njulia> struct MyStruct\n           a\n           b\n       end\n\njulia> S = @setbuild(MyStruct)  # Julia user-type set\nTypeSet(MyStruct)\n\njulia> N = @setbuild([1, 2, 3]) # Enumerable set\nEnumerableSet([{Int64}*3])\n\njulia> C = @setbuild((I, I))  # Cartesian sets\nPredicateSet((c1 ∈ TypeSet(Integer)), (c2 ∈ TypeSet(Integer)) where true)\n\njulia> P = @setbuild(x in I, 0 <= x < 10) # Predicate sets\nPredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)\n\njulia> M = @setbuild(z in I, (x in P) -> x + 5, z -> z - 5) # Mapped sets\nMappedSet((x ∈ PredicateSet((x ∈ TypeSet(Integer)) where 0 <= x < 10)) -> (z ∈ TypeSet(Integer)))\n\n\n\n\n\n","category":"macro"},{"location":"reference/#SetBuilders.@setpkg-Tuple","page":"Reference","title":"SetBuilders.@setpkg","text":"@setpkg command[ command-arguments... ]\n\nThe @setpkg macro enables the reuse of sets that were developed separately.\n\ncommands\n\nload: loads sets from a local file, also known as a setfile\n\n@setpkg load <path/to/file>\n\nThe setfile is a regular Julia module customized for SetBuilders.\n\nExamples\n\nAssuming that the file myset.sjl contains the following Julia code:\n\nmodule MySetModule\n\nexport MYSET\n\nI = @setbuild(Integer)\nMYSET = @setbuild(x in I, x > 0)\n\nend\n\nMYSET can be used as shown in the example below:\n\njulia> @setpkg load \"myset.sjl\"\n\njulia> using SetBuilders.MySetModule\n\njulia> 1 in MYSET\ntrue\n\njulia> 0 in MYSET\nfalse\n\n\n\n\n\n","category":"macro"},{"location":"membership/#Set-Membership","page":"Set Membership","title":"Set Membership","text":"","category":"section"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"This section explains set membership checks using \"in\" or \"∈\" operators by showing various examples.","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"All of the following @assert checks should pass.","category":"page"},{"location":"membership/","page":"Set Membership","title":"Set Membership","text":"# test fixtures\nvalue = 10\n\nstruct MyStruct\n    a\n    b\nend\n\nfunction myfunc(x)\n    x - 5\nend\n\n# Empty set\nE = @setbuild()\n@assert !(1 in E)\n\n# Universal set\nU = @setbuild(Any)\n@assert 1 in U\n\n# sets from Julia types\nI = @setbuild(Integer)\n@assert 1 in I\n@assert !(1.0 in I)\n\nR = @setbuild(Real)\n@assert 1.0 in R\n@assert !(1.0im in R)\n\nS = @setbuild(MyStruct)\n@assert MyStruct(1,2) in S\n@assert !(1 in S)\n\n# Enumerable sets\nA = @setbuild([1, 2, 3])\n@assert 1 in A\n@assert !(4 in A)\n\nB = @setbuild(Int64[value, 2])\n@assert value in B\n@assert !(Int32(value) in B)\n@assert !(3 in B)\npush!(B, 3)\n@assert 3 in B\npop!(B, 3)\n@assert !(3 in B)\n\nC = @setbuild(Dict{String, String}[])\nd1 = Dict{String, String}(\"a\" => \"x\")\nd2 = Dict{String, Integer}(\"a\" => 1)\n@assert !(d1 in C)\npush!(C, d1)\n@assert d1 in C\n@assert !(d2 in C)\n\n# Cartesian sets\nD = @setbuild((I, I))\n@assert (1, 1) in D\n@assert !(1 in D)\n@assert !((1.0, 1.0) in D)\n\nF = @setbuild((x, y) in I)\n@assert (1, 1) in F\n@assert !(1 in F)\n@assert !((1.0, 1.0) in F)\n\nG = @setbuild((I^3, z in I))\n@assert (1, 1, 1, 1) in G\n@assert !(1 in G)\n@assert !((1.0, 1.0, 1.0, 1.0) in G)\n\n# Predicate sets\nH = @setbuild(x in I, 0 <= x < 10)\n@assert 0 in H\n@assert !(10 in H)\n\nJ = @setbuild(x in I, 5 <= x < 15)\n@assert 5 in J\n@assert !(15 in J)\n\nK = @setbuild((x in H, y in J), x < 5 && y > 10)\n@assert (4, 11) in K\n@assert !((9, 10) in K)\n\nL = @setbuild((x in H, y in J), c1*x + c2*y > 0, c1=-1, c2=1)\n@assert (5, 10) in L\n@assert !((9, 5) in L)\n\nM = @setbuild(x in I, x + y > 0, y=value)\n@assert -9 in M\n@assert !(-10 in M)\n\nN = @setbuild(x in @setbuild(Real), x > 0)\n@assert 1 in N\n@assert 1.0 in N\n@assert !(1im in N)\n\n# Mapped sets\nO = @setbuild(z in I, (x in H) -> x + 5, z -> z - 5)\n@assert 5 in O\n@assert !(0 in O)\n\nP = @setbuild(z in I, (x in J) -> x + 5, z -> func(z), func=myfunc)\n@assert 10 in P\n@assert !(5 in P)\n\nQ = @setbuild(z in S, (x in H, y in J) -> mystruct(x, y),\n                z -> (z.a, z.b), mystruct=MyStruct)\n@assert MyStruct(5, 5) in Q\n@assert !(MyStruct(10, 10) in Q)\n","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"CurrentModule = SetBuilders","category":"page"},{"location":"#SetBuilders","page":"SetBuilders Documentation","title":"SetBuilders","text":"","category":"section"},{"location":"#In-a-nutshell...","page":"SetBuilders Documentation","title":"In a nutshell...","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"SetBuilders provides Julia users with the power of predicate-based sets.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Many programming languages, including Julia, support a type of enumerable sets but not predicate sets in the mathematical sense. For instance, in Julia, it's possible to create a set containing integer values, such as","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set([1,2,3])","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, creating the following is not possible:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"A = Set(x ∈ Integer | 0 < x < 4)","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"With the SetBuilders package, Julia users can create predicate sets, compose them using set operations such as unions and intersections, and check if an object is a member of the set.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"I = @setbuild(Integer)           # creates a set from Julia Integer type\nA = @setbuild(x ∈  I, 0 < x < 4) # creates a set with the predicate of \"0 < x < 4\"\nB = @setbuild(x in I, 2 < x < 6) # creates a set with the predicate of \"2 < x < 6\"\nC = A ∩ B                        # creates an intersection with the two sets\n                                 # As an alternative, \"intersect(A, B)\" can be used\n@assert 3 ∈ C                    # => true, 3 is a member of the set C\n                                 # As an alternative, \"3 in C\" can be used\n@assert !(4 in C)                # => true, 4 is not a member of the set C","category":"page"},{"location":"#Installation","page":"SetBuilders Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The package can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"pkg> add SetBuilders","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Alternatively, it can be installed via the Pkg API:","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"julia> import Pkg; Pkg.add(\"SetBuilders\")","category":"page"},{"location":"#Sets-in-Mathematics","page":"SetBuilders Documentation","title":"Sets in Mathematics","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set theory, established by Georg Cantor in the late 19th century, is often regarded as the language of mathematics. It introduces the concept of a set as a collection of distinct objects and provides basic operations such as union, intersection, and difference. The evolution of set theory, marked by milestones like Cantor's work, Russell's Paradox, and the development of the Zermelo-Fraenkel Set Theory (ZF), has shaped it into a robust, axiomatic framework. This transformation solidified set theory's role as the universal language for expressing and structuring mathematical ideas, making it fundamental to the development and understanding of various mathematical disciplines.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"In modern mathematics, set theory's influence is all-encompassing. It is the framework within which most mathematical concepts and theories are formulated and discussed. From the abstract structures in algebra to the nuanced concepts in topology and analysis, set theory provides the essential vocabulary and syntax. It underpins the formation of groups, rings, and fields in algebra, the characterization of space in topology, and the rigorous foundation of calculus in analysis. This universality showcases set theory as not just a branch of mathematics but as the foundational dialect through which mathematics expresses itself.","category":"page"},{"location":"#Sets-in-Programming","page":"SetBuilders Documentation","title":"Sets in Programming","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"In programming languages like Julia and C++, the set data structure serves a specific yet crucial function, primarily focused on managing collections of unique elements. For instance, in Julia, converting an array to a set to eliminate duplicates is straightforward: my_set = Set(my_array). In C++, the Standard Template Library (STL) provides a set container that automatically removes duplicates and maintains element order, instantiated with std::set<int> my_set(my_array, my_array + array_size);.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"However, the application of sets in programming languages is more limited compared to their comprehensive role in mathematics. In mathematics, set theory is a fundamental discipline with wide-ranging implications. In contrast, programming primarily utilizes sets for pragmatic tasks like data manipulation and storage. While indispensable within their scope, these uses do not capture the broad and abstract nature of mathematical set theory. Consequently, sets in programming, despite their utility, represent a more confined aspect of the extensive and foundational role they play in mathematics.","category":"page"},{"location":"#[SetBuilders](https://github.com/grnydawn/SetBuilders.jl):-Harnessing-the-Power-of-Predicate-Based-Sets","page":"SetBuilders Documentation","title":"SetBuilders: Harnessing the Power of Predicate-Based Sets","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set, vital in math, finds new life in programming with Julia's SetBuilders. This tool innovatively allows sets to be defined not just by listing elements but also through predicates - logical formulas yielding true for set members. Predicates in Julia can be any expression yielding a Boolean result, thus enabling sophisticated set definitions through set operations. Additionally, SetBuilders offers features such as set event and customizable set descriptions, greatly enhancing its utility.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"# continues from the code example at the beginning of this page\n\nF = hist -> println(describe(hist[1].set, mark=hist[end].set))\nismember(1, C, on_nomember=F)","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The above example demonstrates how to identify the set that fails the membership test among the sets in the set composition using set event and set description features.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The value 1 is not a member of set C because the predicate of set B excludes it. The following output from the previous code indicates that the \"=>\" mark correctly identifies set B as the reason for exclusion.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"{ x ∈ A | 0 < x < 4 }, where\n    A = { x ∈ ::Integer }\n∩\n => { x ∈ A | 1 < x < 5 }, where\n    A = { x ∈ ::Integer }","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"The function ismember serves a same purpose to the membership operator, in or ∈, but with additional keyword arguments. In the example, on_nomember accepts a function with one input argument, hist, and prints the output from the describe function, which details the structure of the first argument set. Optionally, the describe function accepts a mark keyword argument to indicate a specific set in the output. In this case, hist[end].set is the set that fails the membership test.","category":"page"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"For further details, please continue reading the following manual.","category":"page"},{"location":"#Contents","page":"SetBuilders Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"SetBuilders Documentation","title":"SetBuilders Documentation","text":"Set Creation: explains how to use @setbuild macro for building various types of sets.\nSet Operations: shows examples of using set operations.\nSet Description: explains how to generate set descriptions.\nSet Event: explains how to use set event with a callback function\nSet Element Generation: explains how to generate set elements from Mapped sets.\nSet Sharing: explains how to create/use/share a Julia module for sets\nReference: provides reference manual for using SetBuilders.\nDeveloper Documentaion: explains how to extend SetBuilders.","category":"page"},{"location":"operations/#Set-Operations","page":"Set Operations","title":"Set Operations","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"SetBuilders sets support conventional set operations including union, intersection, difference, symmetric difference, and complement.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"All of the @assert checks in this page should pass.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"To support examples in this page, the following sets are pre-built. To learn how to use @setbuild for the following set creations, see Set Creation.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"I = @setbuild(Integer)\nA = @setbuild(x in I, 0 <= x < 10)\nB = @setbuild(x in I, 5 <= x < 15)\nX = @setbuild(Union{Int64, Int32}[Int32(-1), Int32(1), 2])","category":"page"},{"location":"operations/#Union","page":"Set Operations","title":"Union","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function union or the set operator ∪ performs set union.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 0 in union(A, B)    # 0 is a member of set A\n@assert 14 in A ∪ B         # 14 is a member of set B\n@assert !(-1 in A ∪ B)      # -1 is not a member of either set A or set B","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"note: Note\nThe number of set arguments can be more than two. For example, union(A, B, X) is allowed. \"A ∪ B ∪ X\" is same to \"union(A, B, X)\".This applies to other set operations including intersection, set difference, and set symmetric difference.","category":"page"},{"location":"operations/#Intersection","page":"Set Operations","title":"Intersection","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function intersect or the set operator ∩ performs set intersection.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 5 in intersect(A, B)    # 5 is a member of both set A and set B\n@assert 9 in A ∩ B              # 9 is a member of both set A and set B\n@assert !(0 in A ∩ B)           # 0 is a member of set A, but not of set B","category":"page"},{"location":"operations/#Difference","page":"Set Operations","title":"Difference","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function setdiff or the set operator - performs set difference.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 0 in setdiff(A, B)      # 0 is a member of set A, but not of set B\n@assert 4 in A - B              # 4 is a member of set A, but not of set B\n@assert !(5 in A - B)           # 5 is a member of both set A and set B","category":"page"},{"location":"operations/#Symmetric-Difference","page":"Set Operations","title":"Symmetric Difference","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function symdiff performs set symmetric difference.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 0  in symdiff(A, B)     # 0 is a member of set A, but not of set B\n@assert 10 in symdiff(A, B)     # 10 is a member of set B, but not of set A\n@assert !(5 in symdiff(A, B))   # 5 is a member of both set A and set B","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"note: Note\nWhere there are more than two set arguments, symmetric difference operation is applied as binary operation with previous operation result. For example, symdiff(A, B, X) is evaluated as \"(symdiff(symdiff(A, B), X)\".","category":"page"},{"location":"operations/#Complement","page":"Set Operations","title":"Complement","text":"","category":"section"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"The function complement or the set operator ~ performs set complement.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"A = @setbuild(x in I, 0 <= x < 10)","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"@assert 10 in complement(A)     # 10 is not a member of set A\n!assert !(1 in ~A)              # 1 is a member of set A\n@assert 1 in ~complement(A)     # double complements cancel each other out","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"Also, note that the complement of the EmptySet is the UniversalSet, and vice versa.","category":"page"},{"location":"operations/","page":"Set Operations","title":"Set Operations","text":"E = @setbuild()\nU = @setbuild(Any)\n\n@assert complement(E) == U\n@assert complement(U) == E\n@assert ~U == E\n@assert ~E == U","category":"page"}]
}
